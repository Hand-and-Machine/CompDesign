This folder contains Python scripts I've written to generate 3D geometrical forms as STL files by directly writing the contents of the STL files. I'm sure something similar has been done before by someone else, so I may be reinventing the wheel... but hey, I'm learning a lot by doing this!

The script `stl-Solid.py` contains the basic functions and classes that are required for all other scripts. 

The `Triangle` class is very low-level and is defined by three points. The order of these points is important, since a single facet in an STL file only defines one side of a 2D shape. Initializing a `Triangle` as `Triangle(p1, p2, p3)` will create a facet that is visible from the side on which `p1, p2, p3` appear in counterclockwise order. A `Solid` object may contain many facets, which are added by calling the `Solid.add_face(pts)` method, where `pts` is a list of points. Again, a face added this way will only be visible from the direction in which the list of points `pts` appears in counterclockwise order. Once you have a solid, calling the method `Solid.gen_file()` will render the solid in an STL file with the same name as the solid was given when it was initialized.

The script `stl-Common.py` defines classes for some common solids. Here's a list:

- `Prism(name, base_pts, height)` defines a right prism with base vertices given in an array `base_pts` (listed in counterclockwise order, as viewed from outside the solid) and height `height`.
- `Pyramid(name, base_pts, peak)` defines a pyramid with base vertices given in an array `base_pts` (listed in counterclockwise order, as viewed from the outside) and peak vertex `peak`. Make sure to order the base vertices properly.

It also includes some other tools that allow us to generate solids more easily. Here's a list of other functions defined in `stl-Common.py`:

- `reg_polygon_pts(center, p1, normal, num_pts, adjust_sidelength=0)` generates the points of a regular polygon starting with the point `p1`. The polygon is centered at the point `center` and its vertices are generates counterclockwise about the given normal vector `normal`, and the number of points is specificed by `num_pts`. The optional parameter `adjust_sidelength`, if specified, will scale the polygon about its center so that its side length equals the given value.
- `circumcenter(p1, p2, p3)` finds the circumcenter of three points `p1`, `p2`, and `p3`, or the point in the same plane which is the same distance from all three.
- `equidistant_pt(p1, p2, p3, d)` constructs a point whose distance from each of the points `p1`, `p2`, `p3` is equal to `d`. This is not always possible, depending on the value of `d`, and if it is impossible, the function returns `False`. When a solution exists, there may exist two solutions, which are reflections of each other across the plane in which the three points lie. This function picks out the point on the side of the plane on which the points `p1`, `p2`, and `p3` appear in counterclockwise order.
- `fold_up(p1, p2, p3, theta, phi, length)` is tricky to describe without a picture! Imagine that the three points `p1`, `p2`, `p3` define the corner of a polygon, or two line segments (`p1p2` and `p2p3`) joined at a vertex (`p2`). This function returns a point which, when joined to `p2`, forms a line segment of length `length` which makes an angle of `theta` with the line segment `p1p2` and an angle of `phi` with the line segment `p2p3`. There may exist two such points, which are reflections of each other across the plane in which the three points lie. This function yields the point on the side of the plane from which `p1`, `p2`, and `p3` appear in clockwise order.
  - Why on Earth would we want to do this, you might ask? It's helpful for calculating how three polygonal faces of a solid's net which meet at a vertex "fold up" into three dimensions so that their edges are glued seamlessly together. I'll probably upload an illustration later on showing how this is done.
- `complete_reg_polygon(p1, p2, p3, num_pts)` will, given three vertices `p1`, `p2`, and `p3`, of a regular polygon, as well as the number of vertices `num_pts` of that polygon, return a list of all of the points of that polygon, including the three given.
- `rotate_points_about_line(points, base_pt, vec, theta)` is pretty self-explanatory. Given a list of points `points`, a point `base_pt` and a vector `vec` defining an oriented line, and an angle `theta`, this function rotates each of the points by the given angle about the oriented line, with the direction of rotation determined by the direction of `vec` and the right-hand rule. The images are returned as an array in the same order as the array of points given as input.
